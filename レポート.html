<html>
  <head>
    <meta charset="utf-8" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
    <script src="OrbitControls.js"></script>
    <script>
      // ページの読み込みを待つ
      window.addEventListener('load', init);

      function init() {
        // サイズを指定
        const width = 960;
        const height = 540;

        // レンダラーを作成
        const renderer = new THREE.WebGLRenderer({
          canvas: document.querySelector('#myCanvas')
        });
        renderer.setSize(width, height);
        // 背景の色を設定
        renderer.setClearColor(0xeeeeff);

        // シーンを作成
        const scene = new THREE.Scene();

        // カメラを作成
        const camera = new THREE.PerspectiveCamera(45, width / height);
        // カメラの初期座標を設定
        camera.position.set(0, 0, 1000);

        // カメラコントローラーを作成
        const controls = new THREE.OrbitControls(camera,document.body);
  
        // 平行光源1
        var directionalLight1 = new THREE.DirectionalLight(0xffffff);
        directionalLight1.position.set(100, 100, 100);
        // シーンに追加
        scene.add(directionalLight1);
        // 平行光源2
        var directionalLight2 = new THREE.DirectionalLight(0xffffff);
        directionalLight2.position.set(-100, 100, 100);
        // シーンに追加
        scene.add(directionalLight2);

        // helpe

      const axisHelper = new THREE.AxisHelper(200,50);
      scene.add(axisHelper);
        
        //平面
        const geometry4 = new THREE.BoxGeometry(100,0,500);
    const material4 = new THREE.MeshBasicMaterial({color: 999999});
    const cube0 = new THREE.Mesh(geometry4, material4);
      cube0.position.set(0,1,0);
         scene.add(cube0);
        
        //平面
        const geometry5 = new THREE.BoxGeometry(10,0,40);
        const material5 = new THREE.MeshBasicMaterial;
        const cube1 = new THREE.Mesh(geometry5, material5);
      cube1.position.set(0,2,0);
         scene.add(cube1);
        
         //平面
        const geometry6 = new THREE.BoxGeometry(10,0,40);
        const material6 = new THREE.MeshBasicMaterial;
        const cube2 = new THREE.Mesh(geometry6, material6);
      cube2.position.set(0,2,120);
         scene.add(cube2);
        
        const geometry7 = new THREE.BoxGeometry(10,0,40);
        const material7 = new THREE.MeshBasicMaterial;
        const cube3 = new THREE.Mesh(geometry7, material7);
      cube3.position.set(0,2,-120);
         scene.add(cube3);
        
         const geometry8 = new THREE.BoxGeometry(10,0,30);
        const material8 = new THREE.MeshBasicMaterial;
        const cube4 = new THREE.Mesh(geometry8, material8);
      cube4.position.set(0,2,-235);
         scene.add(cube4);
        
         const geometry9 = new THREE.BoxGeometry(10,0,30);
        const material9 = new THREE.MeshBasicMaterial;
        const cube5 = new THREE.Mesh(geometry9, material9);
      cube5.position.set(0,2,235);
         scene.add(cube5);
        
        const geometry11 = new THREE.BoxGeometry(20,20,500);
        const material11 = new THREE.MeshPhongMaterial({color:0x0000ff});
        const cube6 = new THREE.Mesh(geometry11, material11);
      cube6.position.set(250,10,0);
         scene.add(cube6);
        
        const geometry12 = new THREE.BoxGeometry(20,20,500);
        const material12 = new THREE.MeshPhongMaterial({color:0x00ff00});
        const cube7 = new THREE.Mesh(geometry12, material12);
      cube7.position.set(-250,10,0);
         scene.add(cube7);
        
        //ブロック作成
         const geometry13 = new THREE.BoxGeometry(70,30,100);
        const material13 = new THREE.MeshPhongMaterial({color:0xff0000});
        const box = new THREE.Mesh(geometry13, material13);
      box.position.set(0,30,-180);
         scene.add(box);
        
        const geometry14 = new THREE.BoxGeometry(50,30,70);
        const material14 = new THREE.MeshPhongMaterial({color:0xff0000});
        const box1 = new THREE.Mesh(geometry14, material14);
      box1.position.set(0,50,-180);
         scene.add(box1);
        
        const geometry15 = new THREE.CylinderGeometry(20,20,5,0);
        const material15 = new THREE.MeshPhongMaterial({color:0x000000});
        const box2 = new THREE.Mesh(geometry15, material15);
      box2.position.set(35,20,-210);
        scene.add(box2);
        box2.rotation.z=Math.PI/2;
        
         const geometry16 = new THREE.CylinderGeometry(20,20,5,0);
        const material16 = new THREE.MeshPhongMaterial({color:0x000000});
        const box3 = new THREE.Mesh(geometry16, material16);
      box3.position.set(-35,20,-210);
        scene.add(box3);
        box3.rotation.z=Math.PI/2;
        
        const geometry17 = new THREE.CylinderGeometry(20,20,5,0);
        const material17 = new THREE.MeshPhongMaterial({color:0x000000});
        const box4 = new THREE.Mesh(geometry17, material17);
      box4.position.set(-35,20,-150);
        scene.add(box4);
        box4.rotation.z=Math.PI/2;
        
        const geometry18 = new THREE.CylinderGeometry(20,20,5,0);
        const material18 = new THREE.MeshPhongMaterial({color:0x000000});
        const box5 = new THREE.Mesh(geometry18, material18);
      box5.position.set(35,20,-150);
        scene.add(box5);
        box5.rotation.z=Math.PI/2;
        
        const geometry19 = new THREE.BoxGeometry(70,30,100);
        const material19 = new THREE.MeshPhongMaterial({color:0x0000ff});
        const box6 = new THREE.Mesh(geometry19, material19);
      box6.position.set(0,30,0);
         scene.add(box6);
        
        const geometry20 = new THREE.BoxGeometry(50,30,70);
        const material20 = new THREE.MeshPhongMaterial({color:0x0000ff});
        const box7 = new THREE.Mesh(geometry20, material20);
      box7.position.set(0,50,0);
         scene.add(box7);
        
        const geometry21 = new THREE.CylinderGeometry(20,20,5,0);
        const material21 = new THREE.MeshPhongMaterial({color:0x000000});
        const box8 = new THREE.Mesh(geometry21, material21);
      box8.position.set(35,20,30);
        scene.add(box8);
        box8.rotation.z=Math.PI/2;
        
         const geometry22 = new THREE.CylinderGeometry(20,20,5,0);
        const material22 = new THREE.MeshPhongMaterial({color:0x000000});
        const box9 = new THREE.Mesh(geometry22, material22);
      box9.position.set(-35,20,30);
        scene.add(box9);
        box9.rotation.z=Math.PI/2;
        
        const geometry23 = new THREE.CylinderGeometry(20,20,5,0);
        const material23 = new THREE.MeshPhongMaterial({color:0x000000});
        const box10 = new THREE.Mesh(geometry23, material23);
      box10.position.set(-35,20,-30);
        scene.add(box10);
        box10.rotation.z=Math.PI/2;
        
        const geometry24 = new THREE.CylinderGeometry(20,20,5,0);
        const material24 = new THREE.MeshPhongMaterial({color:0x000000});
        const box11 = new THREE.Mesh(geometry24, material24);
      box11.position.set(35,20,-30);
        scene.add(box11);
        box11.rotation.z=Math.PI/2;
        
        //carのオブジェクト
   const car = new THREE.Group();
     car.add(box6);//車を追加
     car.add(box7); //車を追加
     car.add(box8); //タイヤを追加
     car.add(box9); //タイヤを追加
     car.add(box10); //タイヤを追加
     car.add(box11); //タイヤを追加
        scene.add(car);
     car.position.set(0,0,0);//車グループの原点の位置
        
         
         var update = function() {
      requestAnimationFrame(update);
  
      // 全体を回転させる
        //all.rotation.x += 0.01;
        car.rotation.y += 1;;
  
      renderer.render(scene, camera);
    };
        
        //テクスチャー読み込み
        var textureLoader = new THREE.TextureLoader();  
        var texture = textureLoader.load("img/suna.jpg");
        var mat = new THREE.MeshPhongMaterial();
        mat.map = texture;

        //平面を作成
       　const geometry = new THREE.BoxGeometry(500,0,500);
    const material = new THREE.MeshBasicMaterial({color: 0xff00});
    const cube = new THREE.Mesh(geometry, mat);
        scene.add(cube);
        
        // 木0をスプライトで作成
        var textureLoader = new THREE.TextureLoader();  
        var texture0 = textureLoader.load("img/tree0.png");
        const material0 = new THREE.SpriteMaterial({ map: texture0,});

        const sprite0 = new THREE.Sprite(material0);
        sprite0.position.x = 100;
        sprite0.position.y = 50;
        sprite0.position.z = 100;
        sprite0.scale.set(100,100,100);
        scene.add(sprite0);

        // 木1をスプライトで作成 
        var texture1 = textureLoader.load("img/tree1.png");
        const material1 = new THREE.SpriteMaterial({ map: texture1,});

        const sprite1 = new THREE.Sprite(material1);
        sprite1.position.x = 100;
        sprite1.position.y = 50;
        sprite1.position.z = -100;
        sprite1.scale.set(100,100,100);
        scene.add(sprite1);

        // 木1をスプライトで作成 
        var texture2 = textureLoader.load("img/tree2.png");
        const material2 = new THREE.SpriteMaterial({ map: texture2,});

        const sprite2 = new THREE.Sprite(material2);
        sprite2.position.x = -100;
        sprite2.position.y = 50;
        sprite2.position.z = -100;
        sprite2.scale.set(100,100,100);
        scene.add(sprite2);
        
        // 木1をスプライトで作成 
        var texture3 = textureLoader.load("img/tree1.png");
        const material10 = new THREE.SpriteMaterial({ map: texture3,});

        const sprite4 = new THREE.Sprite(material1);
        sprite4.position.x = -100;
        sprite4.position.y = 50;
        sprite4.position.z = 100;
        sprite4.scale.set(100,100,100);
        scene.add(sprite4);
        
          // 太陽をスプライトで作  
        var texture3 = textureLoader.load("img/sun.png");
        const material3 = new THREE.SpriteMaterial({ map: texture3,});
        
        const sprite3 = new THREE.Sprite(material3);
        sprite3.position.x = -200;
        sprite3.position.y = 500;
        sprite3.position.z = -500;
        sprite3.scale.set(300,300,300);
        scene.add(sprite3);
        
        tick();
        // 毎フレーム時に実行されるループイベントです
        function tick() {
          // レンダリング
          renderer.render(scene, camera);
          requestAnimationFrame(tick);
        }
      }
    </script>
  </head>

  <body>
    <canvas id="myCanvas"></canvas>
  </body>
</html>
© 2021 GitHub, Inc.
